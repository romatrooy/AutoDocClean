Министерство науки и высшего образования РФ
Федеральное государственное автономное
образовательное учреждение высшего образования##ifsdfsdfsd##
«СИБИРСКИЙ ФЕДЕРАЛЬНЫЙ УНИВЕРСИТЕТ»








ОТЧЕТ О ПРАКТИЧЕСКОЙ РАБОТЕ №7
тема











Красноярск 2025
Содержание





















Цели

Ознакомиться с транзакциями.

Задачи

Для выполнения практической работы необходимо выполнить следующие задачи. 

1. По умолчанию каждая SQL-команда, выполняемая в среде psql, образует отдельную транзакцию с уровнем изоляции Read Committed. Поэтому в тех экспериментах, когда одна из транзакций состоит только из единственной SQLкоманды, можно не выполнять команды BEGIN и END. Конечно, если каждая из параллельных транзакций состоит из единственной SQL-команды, то хотя бы для одной из транзакций придется все же выполнить и команду BEGIN, иначе эксперимент не получится. В тексте главы были приведены примеры транзакций, в которых рассматривались команды SELECT ... FOR UPDATE и LOCK TABLE. Попробуйте повторить эти эксперименты с учетом описанного поведения PostgreSQL.
 2. Когда говорят о таком феномене, как потерянное обновление, то зачастую в качестве примера приводится операция UPDATE, в которой значение какого-то атрибута изменяется с применением одного из действий арифметики. Например: UPDATE aircrafts_tmp SET range = range + 200 WHERE aircraft_code = 'CR2'; При выполнении двух и более подобных обновлений в рамках параллельных транзакций, использующих, например, уровень изоляции Read Committed, будут учтены все такие изменения (что и было показано в тексте главы). Очевидно, что потерянного обновления не происходит. Предположим, что в одной транзакции будет просто присваиваться новое значение, например, так: UPDATE aircrafts_tmp SET range = 2100 WHERE aircraft_code = 'CR2'; А в параллельной транзакции будет выполняться аналогичная команда: UPDATE aircrafts_tmp SET range = 2500 WHERE aircraft_code = 'CR2'; 283 Глава 9. Транзакции Очевидно, что сохранится только одно из значений атрибута range. Можно ли говорить, что в такой ситуации имеет место потерянное обновление? Если оно имеет место, то что можно предпринять для его недопущения? Обоснуйте ваш ответ. Для получения дополнительной информации можно обратиться к фундаментальному труду К. Дж. Дейта, а также к полному руководству по SQL Дж. Гроффа, П. Вайнберга и Э. Оппеля. Библиографические описания этих книг приведены в списке рекомендуемой литературы.
3. В тексте главы была рассмотрена команда SELECT ... FOR UPDATE, выполняющая блокировку на уровне отдельных строк. Организуйте две параллельные 285 Глава 9. Транзакции транзакции с уровнем изоляции Read Committed и выполните с ними ряд экспериментов. В первой транзакции заблокируйте некоторое множество строк, отбираемых с помощью условия WHERE. А во второй транзакции изменяйте условие выборки таким образом, чтобы выбираемое множество строк: – являлось подмножеством множества строк, выбираемых в первой транзакции; – являлось надмножеством множества строк, выбираемых в первой транзакции; – пересекалось с множеством строк, выбираемых в первой транзакции; – не пересекалось с множеством строк, выбираемых в первой транзакции. Наблюдайте за поведением команд выборки в каждой транзакции. Попробуйте обобщить ваши наблюдения.
4. В тексте главы для иллюстрации изучаемых концепций мы создавали только две параллельные транзакции. Попробуйте воспроизвести представленные эксперименты, создав три или даже четыре параллельные транзакции.
5. В разделе документации 13.2.3 «Уровень изоляции Serializable» сказано, что если поиск в таблице осуществляется последовательно, без использования индекса, тогда на всю таблицу накладывается так называемая предикатная блокировка. Такой подход приводит к увеличению числа сбоев сериализации. В качестве контрмеры можно попытаться использовать индексы. Конечно, если таблица совсем небольшая, то может и не получиться заставить PostgreSQL использовать поиск по индексу. Тем не менее давайте выполним следующий эксперимент. Для его проведения создадим специальную таблицу, в которой будет всего два столбца: один — числовой, а второй — текстовый. Значения во втором столбце будут иметь вид: LOW1, LOW2, ..., HIGH1, HIGH2, ... Назовем эту таблицу modes. 286 Контрольные вопросы и задания Добавим в нее такое число строк, которое сделает очень вероятным использование индекса при выполнении операций обновления строк и, соответственно, отсутствие предикатной блокировки всей таблицы. О том, как узнать, используется ли индекс при выполнении тех или иных операций, написано в главе 10. CREATE TABLE modes AS SELECT num::integer, 'LOW' || num::text AS mode FROM generate_series( 1, 100000 ) AS gen_ser( num ) UNION ALL SELECT num::integer, 'HIGH' || ( num - 100000 )::text AS mode FROM generate_series( 100001, 200000 ) AS gen_ser( num ); SELECT 200000 Проиндексируем таблицу по числовому столбцу. CREATE INDEX modes_ind ON modes ( num ); CREATE INDEX Из всего множества строк нас будут интересовать только две: SELECT * FROM modes WHERE mode IN ( 'LOW1', 'HIGH1' ); num | mode --------+------- 1 | LOW1 100001 | HIGH1 (2 строки) На первом терминале начнем транзакцию и обновим одну строку из тех двух строк, которые были показаны в предыдущем запросе. BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE; BEGIN UPDATE modes SET mode = 'HIGH1' WHERE num = 1; UPDATE 1 287 Глава 9. Транзакции На втором терминале тоже начнем транзакцию и обновим другую строку из тех двух строк, которые были показаны выше. BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE; BEGIN UPDATE modes SET mode = 'LOW1' WHERE num = 100001; UPDATE 1 Обратите внимание, что обе команды UPDATE были выполнены, ни одна из них не ожидает завершения другой транзакции. Попробуем завершить транзакции. Сначала — на первом терминале: COMMIT; COMMIT А потом на втором терминале: COMMIT; COMMIT Посмотрим, что получилось: SELECT * FROM modes WHERE mode IN ( 'LOW1', 'HIGH1' ); num | mode --------+------- 1 | HIGH1 100001 | LOW1 (2 строки) Теперь система смогла сериализовать параллельные транзакции и зафиксировать их обе. Как вы думаете, почему это удалось? Обосновывая ваш ответ, примите во внимание тот результат, который был бы получен при последовательном выполнении транзакций.































Ход выполнения

Выполнил пункт 1 задач.

SELECT FOR UPDATE









LOCK TABLE









Параллельное обновление










Проверка уровня изоляции READ COMMITTED






Выполнил пункт 2 задач. 

Инкрементное обновление











Абсолютное присваивание







Решения для предотвращения потерянного обновления:

Использование SELECT FOR UPDATE:









Использование более строгого уровня изоляции:










Использование условного обновления:









Выполнил пункт 3 задач

Подмножество







Надмножество









Пересечение









Непересекающиеся множества







Выполнил пункт 4 задач

3 Транзакции Блокируют 4-ую

















Транзакции применяются поочередно после разблокировок предыдущих в очереди

















Выполнил пункт 5 задач










Почему нет конфликта:
Каждая транзакция меняет только одну строку
Строки находятся в разных частях таблицы
Использование индекса позволяет точно определить затрагиваемые строки
Нет зависимости между изменениями





























4 Выводы

Выполнив задание, были изучены транзакции.
Институт космических и информационных технологий
институт
Программная инженерия
кафедра
Транзакции
Преподаватель
Преподаватель



А. Д. Вожжов



подпись, дата

инициалы, фамилия
Студент
КИ23-17/2б, 032320981



Р. А. Троицкий

номер группы, зачетной книжки

подпись, дата

инициалы, фамилия